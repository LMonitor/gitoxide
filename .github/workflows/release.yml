# This is largely adapted from past and recent versions of the ripgrep release workflow.
# https://github.com/BurntSushi/ripgrep/blob/master/.github/workflows/release.yml

name: release

on:
  workflow_dispatch:
  push:
    # Enable when testing release infrastructure on a branch.
    # branches:
     #  - fix-releases
    tags:
      - 'v*'

defaults:
  run:
    shell: bash

jobs:
  # The create-release job runs purely to initialize the GitHub release itself,
  # and names the release after the version tag that was pushed. It's separate
  # from building the release so that we only create the release once.
  create-release:
    name: create-release

    runs-on: ubuntu-latest

#    env:
#      # Set to force version number, e.g., when no tag exists.
#      VERSION: TEST-0.0.0

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Get the release version from the tag
        if: env.VERSION == ''
        run: echo "VERSION=$VERSION" >> "$GITHUB_ENV"
        env:
          VERSION: ${{ github.ref_name }}


      - name: Validate version against Cargo.toml
        run: |
          manifest_version="$(yq -r .package.version Cargo.toml)"
          echo "version to name the release: $VERSION"
          echo "version Cargo.toml suggests: v$manifest_version"

          case "$VERSION" in
          "v$manifest_version" )
            echo 'OK: Release name/version agrees with Cargo.toml version.'
            ;;
          TEST-* | *-DO-NOT-USE )
            echo 'OK: Release name/version is strange but marked as such.'
            ;;
          "$manifest_version" )
            echo 'STOPPING: Release name/version is missing the leading "v".'
            exit 1
            ;;
          * )
            echo 'STOPPING: Release name/version and Cargo.toml version do not match.'
            echo 'STOPPING: Usually this means either a wrong tag name or wrong version in Cargo.toml.'
            echo 'STOPPING: If intended, prepend `TEST-` or append `-DO-NOT-USE` to the release name.'
            exit 1
            ;;
          esac

      - name: Create GitHub release
        id: release
        uses: ncipollo/release-action@v1
        with:
          tag: ${{ env.VERSION }}
          name: ${{ env.VERSION }}
          allowUpdates: true
          draft: true
          omitBody: true
          omitPrereleaseDuringUpdate: true
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Create artifacts directory
        run: mkdir artifacts

      - name: Save release upload URL to artifact
        run: echo "$URL" > artifacts/release-upload-url
        env:
          URL: ${{ steps.release.outputs.upload_url }}

      - name: Save version number to artifact
        run: echo "$VERSION" > artifacts/release-version

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: artifacts
          path: artifacts

  build-release:
    name: build-release

    needs: [ create-release ]

    strategy:
      matrix:
        target:
          - x86_64-unknown-linux-musl
          - arm-unknown-linux-gnueabihf
          - x86_64-apple-darwin
          - aarch64-apple-darwin
          - x86_64-pc-windows-msvc
          - x86_64-pc-windows-gnu
          - i686-pc-windows-msvc
          - aarch64-pc-windows-msvc
        feature:
          - small
          - lean
          - max
          - max-pure
        include:
          - target: x86_64-unknown-linux-musl
            os: ubuntu-latest
            rust: stable
          - target: arm-unknown-linux-gnueabihf
            os: ubuntu-latest
            rust: nightly
          - target: x86_64-apple-darwin
            os: macos-latest
            rust: stable
          - target: aarch64-apple-darwin
            os: macos-latest
            rust: stable
          - target: x86_64-pc-windows-msvc
            os: windows-latest
            rust: nightly
          - target: x86_64-pc-windows-gnu
            os: windows-latest
            rust: nightly-x86_64-gnu
          - target: i686-pc-windows-msvc
            os: windows-latest
            rust: nightly
          - target: aarch64-pc-windows-msvc
            os: windows-latest
            rust: nightly
        # on linux we build with musl which causes trouble with open-ssl. For now, just build max-pure there
        # even though we could also build with `--features max-control,http-client-reqwest,gitoxide-core-blocking-client,gix-features/fast-sha1` for fast hashing.
        # It's a TODO.
        exclude:
          - target: x86_64-unknown-linux-musl
            feature: small
          - target: x86_64-unknown-linux-musl
            feature: lean
          - target: x86_64-unknown-linux-musl
            feature: max
          - target: arm-unknown-linux-gnueabihf
            feature: small
          - target: arm-unknown-linux-gnueabihf
            feature: lean
          - target: arm-unknown-linux-gnueabihf
            feature: max

    runs-on: ${{ matrix.os }}

    env:
      CARGO: cargo  # On Linux, this will be changed to `cross` in a later step.
      TARGET: ${{ matrix.target }}
      TARGET_FLAGS: --target=${{ matrix.target }}
      TARGET_DIR: target/${{ matrix.target }}
      FEATURE: ${{ matrix.feature }}
      RUST_BACKTRACE: '1'  # Emit backtraces on panics.
      CARGO_TERM_COLOR: always
      CLICOLOR: '1'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install packages (Ubuntu)
        # Because openssl doesn't work on musl by default, we resort to max-pure.
        # And that won't need any dependency, so we can skip this or use `continue-on-error`.
        # Once we want to support better zlib performance, we might have to re-add it.
        if: matrix.os == 'ubuntu-latest-disabled'
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends xz-utils liblz4-tool musl-tools

      - name: Install Rust
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: ${{ matrix.rust }}
          targets: ${{ matrix.target }}

      - name: Use Cross
        if: matrix.os == 'ubuntu-latest'
        run: |
          cargo install cross
          echo 'CARGO=cross' >> "$GITHUB_ENV"

      - name: Show command used for Cargo
        run: |
          echo "cargo command is: $CARGO"
          echo "target flag is: $TARGET_FLAGS"
          echo "target dir is: $TARGET_DIR"

      - name: Get release download URL
        uses: actions/download-artifact@v4
        with:
          name: artifacts
          path: artifacts

      - name: Set release upload URL and release version
        run: |
          echo "UPLOAD_URL=$(< artifacts/release-upload-url)" >> "$GITHUB_ENV"
          echo "VERSION=$(< artifacts/release-version)" >> "$GITHUB_ENV"

      - name: Build release binary
        run: |
          "$CARGO" build --verbose --release "$TARGET_FLAGS" --no-default-features --features "$FEATURE"

      - name: Strip release binary (x86-64 Linux, and all macOS)
        if: matrix.target == 'x86_64-unknown-linux-musl' || matrix.os == 'macos-latest'
        run: strip "$TARGET_DIR"/release/{ein,gix}

      - name: Strip release binary (ARM Linux)
        if: matrix.target == 'arm-unknown-linux-gnueabihf'
        run: |
          docker run --rm -v \
            "$PWD/target:/target:Z" \
            rustembedded/cross:arm-unknown-linux-gnueabihf \
            arm-linux-gnueabihf-strip \
            /target/arm-unknown-linux-gnueabihf/release/ein \
            /target/arm-unknown-linux-gnueabihf/release/gix

      - name: Build archive
        run: |
          staging="gitoxide-$FEATURE-$VERSION-$TARGET"
          mkdir -p -- "$staging"

          cp {README.md,LICENSE-*,CHANGELOG.md} "$staging/"

          if [ "$OS" = 'windows-latest' ]; then
            file -- "$TARGET_DIR"/release/{ein,gix}.exe
            cp -- "$TARGET_DIR"/release/{ein,gix}.exe "$staging/"
            7z a "$staging.zip" "$staging"
            echo "ASSET=$staging.zip" >> "$GITHUB_ENV"
          else
            file -- "$TARGET_DIR"/release/{ein,gix}
            cp -- "$TARGET_DIR"/release/{ein,gix} "$staging/"
            tar czf "$staging.tar.gz" "$staging"
            echo "ASSET=$staging.tar.gz" >> "$GITHUB_ENV"
          fi
        env:
          OS: ${{ matrix.os }}

      - name: Upload release archive
        uses: actions/upload-release-asset@v1.0.2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ env.UPLOAD_URL }}
          asset_path: ${{ env.ASSET }}
          asset_name: ${{ env.ASSET }}
          asset_content_type: application/octet-stream
